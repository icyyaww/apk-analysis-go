package ai

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

// InteractionEngine AIé©±åŠ¨çš„äº¤äº’å¼•æ“
type InteractionEngine struct {
	client *Client
	logger *logrus.Logger
}

// NewInteractionEngine åˆ›å»ºäº¤äº’å¼•æ“
func NewInteractionEngine(apiKey string, logger *logrus.Logger) *InteractionEngine {
	return &InteractionEngine{
		client: NewClient(apiKey, logger),
		logger: logger,
	}
}

// Action äº¤äº’åŠ¨ä½œ
type Action struct {
	Type     string `json:"type"`     // click, input, scroll
	X        int    `json:"x,omitempty"`
	Y        int    `json:"y,omitempty"`
	Value    string `json:"value,omitempty"`    // inputç±»å‹çš„è¾“å…¥å€¼
	Direction string `json:"direction,omitempty"` // scrollæ–¹å‘: up/down
	Reason   string `json:"reason"`
	Priority int    `json:"priority"` // 1-16, æ•°å­—è¶Šå¤§è¶Šä¼˜å…ˆ
}

// PlanActions åˆ†æUIå¹¶ç”Ÿæˆäº¤äº’ç­–ç•¥
func (e *InteractionEngine) PlanActions(ctx context.Context, uiData *UIData, activityName string, appCategory string) ([]Action, error) {
	// æ£€æŸ¥æ˜¯å¦æœ‰å¯äº¤äº’å…ƒç´ 
	if len(uiData.ClickableElements) == 0 && len(uiData.InputFields) == 0 {
		e.logger.Info("No interactive elements found")
		return []Action{}, nil
	}

	// æ„å»ºPrompt
	prompt := e.buildAnalysisPrompt(uiData, activityName, appCategory)

	// è°ƒç”¨AIåˆ†æ (ä½¿ç”¨çº¯æ–‡æœ¬æ¨¡å¼,ä¸ä½¿ç”¨æˆªå›¾)
	aiResponse, err := e.callAI(ctx, prompt)
	if err != nil {
		e.logger.WithError(err).Warn("AI call failed, using fallback strategy")
		return e.fallbackStrategy(uiData, activityName), nil
	}

	// è§£æAIå“åº”
	actions := e.parseAIResponse(aiResponse, uiData)
	if len(actions) == 0 {
		e.logger.Warn("No actions generated by AI, using fallback")
		return e.fallbackStrategy(uiData, activityName), nil
	}

	// åŠ¨æ€é™åˆ¶æ“ä½œæ•°
	maxActions := CalculateMaxActions(uiData)
	if len(actions) > maxActions {
		actions = actions[:maxActions]
	}

	return actions, nil
}

// buildAnalysisPrompt æ„å»ºAIåˆ†ææç¤ºè¯
func (e *InteractionEngine) buildAnalysisPrompt(uiData *UIData, activityName string, appCategory string) string {
	// åˆ¤æ–­æ˜¯å¦æ˜¯ä¸»Activity
	isMainActivity := strings.Contains(strings.ToLower(activityName), "main") ||
		strings.Contains(strings.ToLower(activityName), "launcher") ||
		strings.Contains(strings.ToLower(activityName), "splash") ||
		strings.Contains(strings.ToLower(activityName), "welcome")

	// ç®€åŒ–å¯ç‚¹å‡»å…ƒç´ ä¿¡æ¯
	clickableSummary := []string{}
	for i, elem := range uiData.ClickableElements {
		if i >= 15 { // æœ€å¤š15ä¸ª
			break
		}

		displayText := elem.Label
		if displayText == "" {
			displayText = elem.Text
		}

		resourceIDShort := ""
		if elem.ResourceID != "" {
			parts := strings.Split(elem.ResourceID, "/")
			if len(parts) > 0 {
				resourceIDShort = parts[len(parts)-1]
			}
		}

		classShort := ""
		if elem.Class != "" {
			parts := strings.Split(elem.Class, ".")
			if len(parts) > 0 {
				classShort = parts[len(parts)-1]
			}
		}

		summary := fmt.Sprintf("%d. ", i+1)
		if displayText != "" {
			summary += fmt.Sprintf("æ–‡æœ¬:\"%s\" ", displayText)
		}
		if resourceIDShort != "" {
			summary += fmt.Sprintf("ID:%s ", resourceIDShort)
		}
		summary += fmt.Sprintf("ç±»å‹:%s åæ ‡:(%d,%d)", classShort, elem.Center[0], elem.Center[1])

		clickableSummary = append(clickableSummary, summary)
	}

	// è¾“å…¥æ¡†ä¿¡æ¯
	inputSummary := []string{}
	for i, elem := range uiData.InputFields {
		if i >= 5 { // æœ€å¤š5ä¸ª
			break
		}

		summary := fmt.Sprintf("%d. ", i+1)
		if elem.Text != "" {
			summary += fmt.Sprintf("é»˜è®¤æ–‡æœ¬:\"%s\" ", elem.Text)
		}
		if elem.ResourceID != "" {
			parts := strings.Split(elem.ResourceID, "/")
			if len(parts) > 0 {
				summary += fmt.Sprintf("ID:%s ", parts[len(parts)-1])
			}
		}
		summary += fmt.Sprintf("åæ ‡:(%d,%d)", elem.Center[0], elem.Center[1])

		inputSummary = append(inputSummary, summary)
	}

	// æ£€æµ‹ç‰¹æ®ŠæŒ‰é’®
	hasSkipLogin := false
	hasLoginButton := false
	hasBrowsableContent := len(uiData.ClickableElements) > 5 || len(uiData.ScrollableViews) > 0

	skipKeywords := []string{"skip", "later", "è·³è¿‡", "ç¨å", "æ¸¸å®¢", "guest", "visitor", "è¯•ç”¨", "trial", "try", "ä½“éªŒ", "experience"}
	loginKeywords := []string{"login", "signin", "ç™»å½•", "ç™»é™†"}

	for _, elem := range uiData.ClickableElements {
		combined := strings.ToLower(elem.Text + " " + elem.ResourceID + " " + elem.Label)

		for _, kw := range skipKeywords {
			if strings.Contains(combined, kw) {
				hasSkipLogin = true
				break
			}
		}

		for _, kw := range loginKeywords {
			if strings.Contains(combined, kw) {
				hasLoginButton = true
				break
			}
		}
	}

	// åŠ¨æ€è®¡ç®—å»ºè®®æ“ä½œæ•°
	suggestedActions := CalculateMaxActions(uiData)

	// æ„å»ºPrompt
	prompt := fmt.Sprintf(`ä½ æ˜¯ä¸€ä¸ªAndroidåº”ç”¨è‡ªåŠ¨åŒ–æµ‹è¯•ä¸“å®¶ã€‚å½“å‰æ­£åœ¨æµ‹è¯•ä¸€ä¸ªã€%sã€‘ç±»åº”ç”¨çš„ã€%sã€‘ç•Œé¢ã€‚

**ä»»åŠ¡ç›®æ ‡**: æ ¹æ®é¡µé¢å…ƒç´ ,è®¾è®¡%dä¸ªå·¦å³çš„äº¤äº’åŠ¨ä½œ(å¯ä»¥æ›´å¤šæˆ–æ›´å°‘,è§†å®é™…æƒ…å†µè€Œå®š),ä»¥è§¦å‘å°½å¯èƒ½å¤šçš„ç½‘ç»œè¯·æ±‚(ä¼˜å…ˆHTTP/HTTPS APIè°ƒç”¨)ã€‚

**é‡è¦æç¤º**:
- å¦‚æœå‘ç°"åŒæ„/å…è®¸/ç¡®å®š"ç­‰æƒé™æŒ‰é’®,**åªè¿”å›ç‚¹å‡»è¿™ä¸ªæŒ‰é’®çš„ä¸€ä¸ªåŠ¨ä½œå³å¯**,å› ä¸ºç‚¹å‡»åé¡µé¢ä¼šè·³è½¬
- é¿å…åœ¨åŒä¸€ä¸ªé¡µé¢ä¸Šè¿ç»­ç‚¹å‡»å¤šä¸ªäº’æ–¥æŒ‰é’®(å¦‚"åŒæ„"å’Œ"ä¸åŒæ„")
- ä¼˜å…ˆæ‰§è¡Œä¼šå¯¼è‡´é¡µé¢è·³è½¬çš„é«˜ä»·å€¼åŠ¨ä½œ

**å½“å‰ç•Œé¢åˆ†æ**:
- æ˜¯å¦æ˜¯ä¸»Activity: %t
- æ˜¯å¦æœ‰è·³è¿‡ç™»å½•é€‰é¡¹: %t
- æ˜¯å¦æœ‰ç™»å½•æŒ‰é’®: %t
- æ˜¯å¦æœ‰å¯æµè§ˆå†…å®¹: %t

**UIå¯äº¤äº’å…ƒç´ **:
%s

**è¾“å…¥æ¡†**:
%s

**äº¤äº’ç­–ç•¥è¦æ±‚**:
0. **ğŸ”¥ ç³»ç»Ÿ"Open"æŒ‰é’®(è¶…é«˜ä¼˜å…ˆçº§ - ä¼˜å…ˆçº§16)**:
   - **åœºæ™¯**: Androidç³»ç»Ÿè®¾ç½®çš„"App info"é¡µé¢
   - **å¿…é¡»æœ€ä¼˜å…ˆç‚¹å‡»**: Open/æ‰“å¼€/Launch/å¯åŠ¨
   - **ä½œç”¨**: ä»ç³»ç»Ÿè®¾ç½®é¡µé¢å¯åŠ¨åº”ç”¨è¿›å…¥åº”ç”¨å†…éƒ¨
   - **é‡è¦**: å¦‚æœç•Œé¢æœ‰"Open", "Uninstall", "Force stop"ä¸‰ä¸ªæŒ‰é’®,åªèƒ½ç‚¹å‡»"Open"!
1. **æƒé™åŒæ„ç­–ç•¥(æœ€é«˜ä¼˜å…ˆçº§ - ä¼˜å…ˆçº§15)**:
   - **å¿…é¡»ä¼˜å…ˆç‚¹å‡»**: åŒæ„/å…è®¸/ç¡®å®š/Accept/Allow/Agree/OK/æˆæƒ/Grant/ç»§ç»­/Continue
   - **è¿™äº›æŒ‰é’®é€šå¸¸åœ¨æƒé™å¼¹çª—/æœåŠ¡åè®®/éšç§æ”¿ç­–é¡µé¢å‡ºç°**
   - **ç¤ºä¾‹**: "åŒæ„å¹¶ç»§ç»­"(ä¼˜å…ˆçº§15) vs "ä¸åŒæ„"(ç¦æ­¢ç‚¹å‡»)
2. **ç™»å½•ç­–ç•¥(æ¬¡é«˜ä¼˜å…ˆçº§ - ä¼˜å…ˆçº§14)** - ç›®æ ‡æ˜¯åœ¨ä¸ç™»å½•æƒ…å†µä¸‹æµè§ˆAPP:
   - **ä¼˜å…ˆçº§14**: ç‚¹å‡»"è·³è¿‡ç™»å½•/ç¨å/æ¸¸å®¢æ¨¡å¼/è¯•ç”¨/ä½“éªŒ/å…è´¹è¯•ç”¨/å…ç™»å½•ä½“éªŒ/æš‚ä¸ç™»å½•/å…ˆé€›é€›"
   - **åªåœ¨ç‰¹æ®Šæƒ…å†µç‚¹å‡»ç™»å½•**: å½“å‰æ˜¯ä¸»Activityä¸”ç•Œé¢åªæœ‰ç™»å½•/æ³¨å†ŒæŒ‰é’®(æ— å…¶ä»–å¯ç‚¹å‡»å†…å®¹)ä¸”æ²¡æœ‰è·³è¿‡é€‰é¡¹
   - **å¦‚æœæœ‰å¯æµè§ˆå†…å®¹**: ä¼˜å…ˆæµè§ˆå†…å®¹,å®Œå…¨å¿½ç•¥ç™»å½•æŒ‰é’®
   - **æ³¨æ„åŒºåˆ†**: "ç™»å½•"(Login/Sign in) vs "é€€å‡ºç™»å½•"(Sign out/Logout) - åè€…ä¸è¦ç‚¹å‡»
3. ä¼˜å…ˆç‚¹å‡»é«˜ä»·å€¼æŒ‰é’®: æœç´¢/åˆ·æ–°/åˆ†äº«/å‘é€/æŸ¥çœ‹è¯¦æƒ…/æµè§ˆ/è¿›å…¥/æ›´å¤š (ä¼˜å…ˆçº§10-12)
4. **ğŸš« ç»å¯¹ç¦æ­¢ç‚¹å‡»(ä¼˜å…ˆçº§å¿…é¡»ä¸º0æˆ–ä¸è¿”å›)**:
   - **æ‹’ç»ç±»**: æ‹’ç»/ä¸åŒæ„/ç¦æ­¢/Deny/Refuse/Disagree/Decline
   - **å¦å®šç±»**: å¦/ä¸/No/Nope
   - **å–æ¶ˆç±»**: å–æ¶ˆ/Cancel
   - **é€€å‡ºç±»**: è¿”å›/å…³é—­/é€€å‡º/é€€å‡ºç™»å½•/back/exit/quit/sign out/logout/close
   - **é‡è¦**: å¦‚æœç•Œé¢åŒæ—¶æœ‰"åŒæ„"å’Œ"ä¸åŒæ„"æŒ‰é’®,åªèƒ½è¿”å›"åŒæ„"çš„ç‚¹å‡»åŠ¨ä½œ!
5. å¦‚æœç•Œé¢å¯æ»šåŠ¨,ä¼˜å…ˆæ»šåŠ¨æµè§ˆå†…å®¹ (ä¼˜å…ˆçº§8)
6. æ¯ä¸ªåŠ¨ä½œå¿…é¡»ä¿è¯ç”¨æˆ·åœç•™åœ¨APPå†…éƒ¨,ä¸èƒ½é€€å‡ºåˆ°æ¡Œé¢

**è¾“å‡ºæ ¼å¼** (ä¸¥æ ¼JSONæ•°ç»„):
` + "```json" + `
[
  {
    "type": "click",
    "x": 540,
    "y": 875,
    "reason": "ç‚¹å‡»ç™»å½•æŒ‰é’®,è§¦å‘è®¤è¯APIè¯·æ±‚",
    "priority": 10
  },
  {
    "type": "input",
    "x": 540,
    "y": 500,
    "value": "test@example.com",
    "reason": "å¡«å†™é‚®ç®±è¾“å…¥æ¡†",
    "priority": 9
  },
  {
    "type": "scroll",
    "direction": "down",
    "reason": "å‘ä¸‹æ»šåŠ¨åŠ è½½æ›´å¤šå†…å®¹",
    "priority": 5
  }
]
` + "```" + `

**æ³¨æ„**:
- åªè¿”å›JSONæ•°ç»„,ä¸è¦å…¶ä»–è§£é‡Š
- priorityèŒƒå›´1-16,æ•°å­—è¶Šå¤§è¶Šä¼˜å…ˆ
- typeåªèƒ½æ˜¯: click / input / scroll
- åæ ‡å¿…é¡»åœ¨å±å¹•èŒƒå›´å†…(0-1080, 0-2340)`,
		appCategory,
		activityName,
		suggestedActions,
		isMainActivity,
		hasSkipLogin,
		hasLoginButton,
		hasBrowsableContent,
		formatList(clickableSummary),
		formatList(inputSummary),
	)

	return prompt
}

// formatList æ ¼å¼åŒ–åˆ—è¡¨
func formatList(items []string) string {
	if len(items) == 0 {
		return "(æ— )"
	}
	return strings.Join(items, "\n")
}

// callAI è°ƒç”¨AI API
func (e *InteractionEngine) callAI(ctx context.Context, prompt string) (string, error) {
	// ä½¿ç”¨ glm-4v-flash æ¨¡å‹ï¼Œç¦ç”¨æ·±åº¦æ€è€ƒä»¥åŠ å¿«å“åº”
	reqBody := ChatRequest{
		Model:    "glm-4v-flash",
		Thinking: &ThinkingConfig{Type: "disabled"},
		Messages: []Message{
			{
				Role: "user",
				Content: []ContentPart{
					{
						Type: "text",
						Text: prompt,
					},
				},
			},
		},
	}

	resp, err := e.client.sendChatRequest(ctx, reqBody)
	if err != nil {
		return "", err
	}

	if len(resp.Choices) == 0 {
		return "", fmt.Errorf("no response from AI")
	}

	return resp.Choices[0].Message.Content, nil
}

// parseAIResponse è§£æAIè¿”å›çš„JSONå“åº”
func (e *InteractionEngine) parseAIResponse(response string, uiData *UIData) []Action {
	// æå–JSON (å¯èƒ½è¢«```åŒ…è£¹ï¼Œæ”¯æŒå¤šè¡ŒJSON)
	// (?s) å¯ç”¨ DOTALL æ¨¡å¼ï¼Œè®© . åŒ¹é…æ¢è¡Œç¬¦
	re := regexp.MustCompile("(?s)```json\\s*(\\[.*?\\])\\s*```")
	matches := re.FindStringSubmatch(response)

	var jsonStr string
	if len(matches) > 1 {
		jsonStr = matches[1]
	} else {
		// å°è¯•ç›´æ¥è§£ææ•´ä¸ªå“åº”
		jsonStr = response
	}

	var actions []Action
	if err := json.Unmarshal([]byte(jsonStr), &actions); err != nil {
		e.logger.WithError(err).WithField("response", response[:min(len(response), 200)]).Warn("Failed to parse AI response")
		return []Action{}
	}

	// ç¦æ­¢å…³é”®è¯åˆ—è¡¨
	forbiddenKeywords := []string{
		"è¿”å›", "back", "å…³é—­", "close",
		"é€€å‡º", "exit", "quit",
		"æ‹’ç»", "deny", "refuse", "ä¸åŒæ„", "disagree", "decline",
		"ç¦æ­¢", "forbid", "å¦", "no", "nope", "å–æ¶ˆ", "cancel",
		"é€€å‡ºç™»å½•", "sign out", "logout",
	}

	// éªŒè¯å’Œè¿‡æ»¤
	validActions := []Action{}
	for _, action := range actions {
		// æ£€æŸ¥ç±»å‹
		if action.Type != "click" && action.Type != "input" && action.Type != "scroll" {
			continue
		}

		// æ£€æŸ¥reasonæ˜¯å¦åŒ…å«ç¦æ­¢å…³é”®è¯
		if action.Type == "click" {
			reason := strings.ToLower(action.Reason)
			isForbidden := false
			for _, kw := range forbiddenKeywords {
				if strings.Contains(reason, kw) {
					e.logger.WithField("reason", action.Reason).Info("Filtered forbidden action")
					isForbidden = true
					break
				}
			}
			if isForbidden {
				continue
			}
		}

		validActions = append(validActions, action)
	}

	// æŒ‰ä¼˜å…ˆçº§æ’åº (ä»é«˜åˆ°ä½)
	for i := 0; i < len(validActions); i++ {
		for j := i + 1; j < len(validActions); j++ {
			if validActions[j].Priority > validActions[i].Priority {
				validActions[i], validActions[j] = validActions[j], validActions[i]
			}
		}
	}

	return validActions
}

// fallbackStrategy é™çº§ç­–ç•¥: åŸºäºè§„åˆ™ç”Ÿæˆç®€å•äº¤äº’
func (e *InteractionEngine) fallbackStrategy(uiData *UIData, activityName string) []Action {
	actions := []Action{}

	// åˆ¤æ–­æ˜¯å¦æ˜¯ä¸»Activity
	isMainActivity := strings.Contains(strings.ToLower(activityName), "main") ||
		strings.Contains(strings.ToLower(activityName), "launcher") ||
		strings.Contains(strings.ToLower(activityName), "splash") ||
		strings.Contains(strings.ToLower(activityName), "welcome")

	// å…³é”®è¯åˆ—è¡¨
	openKeywords := []string{"open", "æ‰“å¼€", "launch", "å¯åŠ¨"}
	agreeKeywords := []string{"åŒæ„", "agree", "å…è®¸", "allow", "ç¡®å®š", "ok", "accept", "æˆæƒ", "grant", "ç»§ç»­", "continue"}
	skipLoginKeywords := []string{"skip", "later", "è·³è¿‡", "ç¨å", "æ¸¸å®¢", "guest", "visitor", "è¯•ç”¨", "trial", "try", "ä½“éªŒ", "experience"}
	loginKeywords := []string{"login", "signin", "ç™»å½•", "ç™»é™†", "register", "æ³¨å†Œ"}
	highPriorityKeywords := []string{"æœç´¢", "search", "åˆ·æ–°", "refresh", "åˆ†äº«", "share", "å‘é€", "send", "æŸ¥çœ‹", "view", "è¯¦æƒ…", "detail", "æ›´å¤š", "more"}
	forbiddenKeywords := []string{"è¿”å›", "back", "å…³é—­", "close", "é€€å‡º", "exit", "quit", "æ‹’ç»", "deny", "refuse", "ä¸åŒæ„", "disagree", "ç¦æ­¢", "forbid", "å¦", "no", "å–æ¶ˆ", "cancel"}

	// æ£€æŸ¥æ˜¯å¦æœ‰è·³è¿‡ç™»å½•é€‰é¡¹å’Œå¯æµè§ˆå†…å®¹
	hasSkipOption := false
	hasLoginOnly := true
	hasBrowsableContent := len(uiData.ClickableElements) > 5

	for _, elem := range uiData.ClickableElements {
		combined := strings.ToLower(elem.Label + " " + elem.Text + " " + elem.ResourceID)

		// æ£€æµ‹è·³è¿‡ç™»å½•é€‰é¡¹
		for _, kw := range skipLoginKeywords {
			if strings.Contains(combined, kw) {
				hasSkipOption = true
				break
			}
		}

		// å¦‚æœæœ‰éç™»å½•æŒ‰é’®ï¼Œè¯´æ˜ä¸æ˜¯çº¯ç™»å½•é¡µ
		isLogin := false
		for _, kw := range loginKeywords {
			if strings.Contains(combined, kw) {
				isLogin = true
				break
			}
		}
		isSkip := false
		for _, kw := range skipLoginKeywords {
			if strings.Contains(combined, kw) {
				isSkip = true
				break
			}
		}

		if !isLogin && !isSkip && (elem.Text != "" || strings.Contains(elem.ResourceID, "btn") || strings.Contains(elem.ResourceID, "item")) {
			hasLoginOnly = false
		}
	}

	// å¤„ç†å¯ç‚¹å‡»å…ƒç´ 
	for _, elem := range uiData.ClickableElements {
		if len(actions) >= 5 { // é™çº§ç­–ç•¥æœ€å¤š5ä¸ªåŠ¨ä½œ
			break
		}

		combined := strings.ToLower(elem.Label + " " + elem.Text + " " + elem.ResourceID)

		// æ£€æŸ¥æ˜¯å¦ç¦æ­¢
		isForbidden := false
		for _, kw := range forbiddenKeywords {
			if strings.Contains(combined, kw) {
				isForbidden = true
				break
			}
		}
		if isForbidden {
			continue
		}

		// åˆ¤æ–­ä¼˜å…ˆçº§
		score := 5

		// OpenæŒ‰é’®
		isOpen := false
		for _, kw := range openKeywords {
			if strings.Contains(combined, kw) {
				isOpen = true
				score = 16
				break
			}
		}

		// æƒé™åŒæ„
		isAgree := false
		if !isOpen {
			for _, kw := range agreeKeywords {
				if strings.Contains(combined, kw) {
					isAgree = true
					score = 15
					break
				}
			}
		}

		// è·³è¿‡ç™»å½•
		isSkipLogin := false
		if !isOpen && !isAgree {
			for _, kw := range skipLoginKeywords {
				if strings.Contains(combined, kw) {
					isSkipLogin = true
					score = 14
					break
				}
			}
		}

		// ç™»å½•æŒ‰é’® - é™ä½ä¼˜å…ˆçº§ï¼Œå°½é‡é¿å…ç‚¹å‡»
		isLogin := false
		if !isOpen && !isAgree && !isSkipLogin {
			for _, kw := range loginKeywords {
				if strings.Contains(combined, kw) {
					isLogin = true
					// åªåœ¨ç‰¹å®šæƒ…å†µä¸‹ç‚¹å‡»ç™»å½•ï¼Œä¸”ä¼˜å…ˆçº§å¾ˆä½
					if isMainActivity && hasLoginOnly && !hasSkipOption {
						score = 3 // é™ä½ä¼˜å…ˆçº§ä»8åˆ°3
					} else {
						continue // è·³è¿‡ç™»å½•æŒ‰é’®
					}
					break
				}
			}
		}

		// é«˜ä»·å€¼æŒ‰é’®
		if !isOpen && !isAgree && !isSkipLogin && !isLogin {
			for _, kw := range highPriorityKeywords {
				if strings.Contains(combined, kw) {
					score = 10
					break
				}
			}
		}

		// æ„å»ºæè¿°æ–‡æœ¬
		descText := elem.Label
		if descText == "" {
			descText = elem.Text
		}
		if descText == "" {
			parts := strings.Split(elem.ResourceID, "/")
			if len(parts) > 0 {
				descText = parts[len(parts)-1]
			}
		}
		if descText == "" {
			descText = "(æ— æ–‡æœ¬)"
		}

		actions = append(actions, Action{
			Type:     "click",
			X:        elem.Center[0],
			Y:        elem.Center[1],
			Reason:   fmt.Sprintf("ç‚¹å‡»æŒ‰é’®: %s", descText),
			Priority: score,
		})
	}

	// å¦‚æœæœ‰å¯æµè§ˆå†…å®¹ï¼Œæ·»åŠ æ»šåŠ¨æ“ä½œ
	if hasBrowsableContent && len(uiData.ScrollableViews) > 0 {
		actions = append(actions, Action{
			Type:      "scroll",
			Direction: "down",
			Reason:    "å‘ä¸‹æ»šåŠ¨æµè§ˆæ›´å¤šå†…å®¹",
			Priority:  12,
		})
	}

	// æ’åº
	for i := 0; i < len(actions); i++ {
		for j := i + 1; j < len(actions); j++ {
			if actions[j].Priority > actions[i].Priority {
				actions[i], actions[j] = actions[j], actions[i]
			}
		}
	}

	return actions
}

// ExecuteAction æ‰§è¡Œå•ä¸ªåŠ¨ä½œ (éœ€è¦ADBå®¢æˆ·ç«¯é…åˆ)
type ActionExecutor interface {
	TapScreen(ctx context.Context, x, y int) error
	InputText(ctx context.Context, text string) error
	Shell(ctx context.Context, command string) (string, error)
	GetForegroundPackage(ctx context.Context) (string, error)
	StartActivity(ctx context.Context, component string) error
	PressBack(ctx context.Context) error
}

// ExecuteAction æ‰§è¡ŒåŠ¨ä½œ
func (e *InteractionEngine) ExecuteAction(ctx context.Context, action Action, executor ActionExecutor) error {
	e.logger.WithFields(logrus.Fields{
		"type":     action.Type,
		"reason":   action.Reason,
		"priority": action.Priority,
	}).Info("Executing action")

	switch action.Type {
	case "click":
		return executor.TapScreen(ctx, action.X, action.Y)

	case "input":
		// å…ˆç‚¹å‡»è¾“å…¥æ¡†èšç„¦
		if err := executor.TapScreen(ctx, action.X, action.Y); err != nil {
			return err
		}
		time.Sleep(500 * time.Millisecond)
		// è¾“å…¥æ–‡æœ¬
		return executor.InputText(ctx, action.Value)

	case "scroll":
		// æ»šåŠ¨æ“ä½œ
		var cmd string
		if action.Direction == "down" {
			cmd = "input swipe 540 1500 540 500 300"
		} else {
			cmd = "input swipe 540 500 540 1500 300"
		}
		_, err := executor.Shell(ctx, cmd)
		return err

	default:
		return fmt.Errorf("unknown action type: %s", action.Type)
	}
}

// min è¿”å›æœ€å°å€¼
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ========== æ“ä½œå®‰å…¨æ£€æŸ¥ç›¸å…³å‡½æ•° ==========

// PreCheckResult æ“ä½œå‰æ£€æŸ¥ç»“æœ
type PreCheckResult struct {
	Safe       bool   // æ˜¯å¦å®‰å…¨å¯æ‰§è¡Œ
	Reason     string // æ‹’ç»åŸå› ï¼ˆå¦‚æœä¸å®‰å…¨ï¼‰
	Element    *UIElement // æ‰¾åˆ°çš„ç›®æ ‡å…ƒç´ ï¼ˆå¯èƒ½ä¸ºnilï¼‰
}

// PreCheckAction æ“ä½œå‰æ£€æŸ¥
// æ£€æŸ¥ç›®æ ‡åæ ‡çš„å…ƒç´ æ˜¯å¦å±äºç›®æ ‡åº”ç”¨ï¼Œé¿å…è¯¯ç‚¹å‡»ç³»ç»ŸUIæˆ–å…¶ä»–åº”ç”¨
func (e *InteractionEngine) PreCheckAction(action Action, uiXML string, targetPackage string, screenWidth, screenHeight int) PreCheckResult {
	// åªæ£€æŸ¥ç‚¹å‡»æ“ä½œ
	if action.Type != "click" {
		return PreCheckResult{Safe: true, Reason: "éç‚¹å‡»æ“ä½œï¼Œè·³è¿‡æ£€æŸ¥"}
	}

	// 1. é¦–å…ˆæ£€æŸ¥åæ ‡æ˜¯å¦åœ¨å±é™©åŒºåŸŸ
	if IsDangerousZone(action.X, action.Y, screenWidth, screenHeight) {
		return PreCheckResult{
			Safe:   false,
			Reason: fmt.Sprintf("åæ ‡(%d,%d)ä½äºå±é™©åŒºåŸŸï¼ˆçŠ¶æ€æ /å¯¼èˆªæ /è¾¹ç¼˜ï¼‰", action.X, action.Y),
		}
	}

	// 2. å¦‚æœæœ‰ UI XMLï¼ŒæŸ¥æ‰¾ç›®æ ‡å…ƒç´ å¹¶æ£€æŸ¥åŒ…å
	if uiXML != "" {
		element, err := FindElementByCoords(uiXML, action.X, action.Y)
		if err != nil {
			// æ‰¾ä¸åˆ°å…ƒç´ ï¼Œå¯èƒ½æ˜¯åæ ‡è¶…å‡ºUIèŒƒå›´
			e.logger.WithError(err).WithFields(logrus.Fields{
				"x": action.X,
				"y": action.Y,
			}).Debug("æ— æ³•æ‰¾åˆ°åæ ‡å¯¹åº”çš„å…ƒç´ ")
			// æ‰¾ä¸åˆ°å…ƒç´ æ—¶ä¸é˜»æ­¢æ“ä½œï¼Œå¯èƒ½æ˜¯åŠ¨æ€å†…å®¹
			return PreCheckResult{Safe: true, Reason: "æœªæ‰¾åˆ°å…ƒç´ ï¼Œå…è®¸æ“ä½œ", Element: nil}
		}

		// 3. æ£€æŸ¥å…ƒç´ æ˜¯å¦å®‰å…¨
		if !IsElementSafe(element, targetPackage) {
			return PreCheckResult{
				Safe:    false,
				Reason:  fmt.Sprintf("å…ƒç´ å±äºå…¶ä»–åº”ç”¨(%s)ï¼Œå¯èƒ½å¯¼è‡´é€€å‡º", element.Package),
				Element: element,
			}
		}

		return PreCheckResult{
			Safe:    true,
			Reason:  "å…ƒç´ å®‰å…¨",
			Element: element,
		}
	}

	// æ²¡æœ‰ UI XML æ•°æ®ï¼Œé»˜è®¤å…è®¸
	return PreCheckResult{Safe: true, Reason: "æ— UIæ•°æ®ï¼Œå…è®¸æ“ä½œ"}
}

// PostRecoveryCheck æ“ä½œåæ¢å¤æ£€æŸ¥
// æ£€æŸ¥å½“å‰å‰å°åº”ç”¨æ˜¯å¦ä»æ˜¯ç›®æ ‡åº”ç”¨ï¼Œå¦‚æœä¸æ˜¯åˆ™å°è¯•æ¢å¤
func (e *InteractionEngine) PostRecoveryCheck(ctx context.Context, executor ActionExecutor, targetPackage string, targetActivity string) error {
	// ç­‰å¾…æ“ä½œå®Œæˆå’Œé¡µé¢ç¨³å®š
	time.Sleep(500 * time.Millisecond)

	// æ£€æŸ¥å½“å‰å‰å°åº”ç”¨
	currentPackage, err := executor.GetForegroundPackage(ctx)
	if err != nil {
		e.logger.WithError(err).Warn("æ— æ³•è·å–å‰å°åº”ç”¨åŒ…å")
		// è·å–å¤±è´¥ä¸é˜»å¡æµç¨‹
		return nil
	}

	// å¦‚æœä»åœ¨ç›®æ ‡åº”ç”¨ä¸­ï¼Œæ— éœ€æ¢å¤
	if currentPackage == targetPackage {
		return nil
	}

	e.logger.WithFields(logrus.Fields{
		"current_package": currentPackage,
		"target_package":  targetPackage,
	}).Warn("åº”ç”¨å·²é€€å‡ºåˆ°å…¶ä»–åº”ç”¨ï¼Œå°è¯•æ¢å¤")

	// å°è¯•æ¢å¤ï¼ˆæœ€å¤š3æ¬¡ï¼‰
	for attempt := 1; attempt <= 3; attempt++ {
		var recoverErr error

		switch attempt {
		case 1:
			// ç¬¬ä¸€æ¬¡ï¼šæŒ‰è¿”å›é”®
			e.logger.Info("æ¢å¤å°è¯•1: æŒ‰è¿”å›é”®")
			recoverErr = executor.PressBack(ctx)

		case 2:
			// ç¬¬äºŒæ¬¡ï¼šå†æŒ‰è¿”å›é”®
			e.logger.Info("æ¢å¤å°è¯•2: å†æ¬¡æŒ‰è¿”å›é”®")
			recoverErr = executor.PressBack(ctx)

		case 3:
			// ç¬¬ä¸‰æ¬¡ï¼šå¼ºåˆ¶å¯åŠ¨ç›®æ ‡ Activity
			e.logger.Info("æ¢å¤å°è¯•3: å¼ºåˆ¶å¯åŠ¨ç›®æ ‡Activity")
			if targetActivity != "" {
				recoverErr = executor.StartActivity(ctx, targetActivity)
			} else {
				// å¦‚æœæ²¡æœ‰æŒ‡å®š Activityï¼Œå°è¯•é€šè¿‡ monkey å¯åŠ¨ä¸» Activity
				_, recoverErr = executor.Shell(ctx, fmt.Sprintf("monkey -p %s -c android.intent.category.LAUNCHER 1", targetPackage))
			}
		}

		if recoverErr != nil {
			e.logger.WithError(recoverErr).WithField("attempt", attempt).Warn("æ¢å¤æ“ä½œæ‰§è¡Œå¤±è´¥")
			continue
		}

		// ç­‰å¾…æ¢å¤å®Œæˆ
		time.Sleep(1 * time.Second)

		// å†æ¬¡æ£€æŸ¥å‰å°åº”ç”¨
		currentPackage, err = executor.GetForegroundPackage(ctx)
		if err != nil {
			continue
		}

		if currentPackage == targetPackage {
			e.logger.WithField("attempt", attempt).Info("åº”ç”¨æ¢å¤æˆåŠŸ")
			return nil
		}
	}

	// æ¢å¤å¤±è´¥
	return fmt.Errorf("åº”ç”¨æ¢å¤å¤±è´¥ï¼šå½“å‰å‰å°åº”ç”¨ä¸º %sï¼Œç›®æ ‡åº”ç”¨ä¸º %s", currentPackage, targetPackage)
}

// ExecuteActionSafe å®‰å…¨æ‰§è¡ŒåŠ¨ä½œï¼ˆå¸¦å‰ç½®æ£€æŸ¥å’Œåç½®æ¢å¤ï¼‰
// è¿™æ˜¯ ExecuteAction çš„å¢å¼ºç‰ˆæœ¬ï¼Œé›†æˆäº†å®‰å…¨æ£€æŸ¥æœºåˆ¶
func (e *InteractionEngine) ExecuteActionSafe(ctx context.Context, action Action, executor ActionExecutor, targetPackage string, targetActivity string, uiXML string, screenWidth, screenHeight int) error {
	// 1. æ“ä½œå‰æ£€æŸ¥
	preCheck := e.PreCheckAction(action, uiXML, targetPackage, screenWidth, screenHeight)
	if !preCheck.Safe {
		e.logger.WithFields(logrus.Fields{
			"action_type": action.Type,
			"reason":      action.Reason,
			"reject_reason": preCheck.Reason,
			"x":           action.X,
			"y":           action.Y,
		}).Warn("æ“ä½œè¢«å®‰å…¨æ£€æŸ¥æ‹¦æˆªï¼Œè·³è¿‡æ­¤æ“ä½œ")
		return nil // è¿”å›nilï¼Œä¸ä¸­æ–­åç»­æ“ä½œ
	}

	// è®°å½•é€šè¿‡æ£€æŸ¥çš„æ—¥å¿—
	if preCheck.Element != nil {
		e.logger.WithFields(logrus.Fields{
			"action_type":     action.Type,
			"element_package": preCheck.Element.Package,
			"element_text":    preCheck.Element.Text,
		}).Debug("æ“ä½œé€šè¿‡å®‰å…¨æ£€æŸ¥")
	}

	// 2. æ‰§è¡Œæ“ä½œ
	err := e.ExecuteAction(ctx, action, executor)
	if err != nil {
		return err
	}

	// 3. æ“ä½œåæ¢å¤æ£€æŸ¥ï¼ˆä»…å¯¹ç‚¹å‡»æ“ä½œï¼‰
	if action.Type == "click" {
		if recoveryErr := e.PostRecoveryCheck(ctx, executor, targetPackage, targetActivity); recoveryErr != nil {
			e.logger.WithError(recoveryErr).Warn("åº”ç”¨æ¢å¤å¤±è´¥ï¼Œå¯èƒ½å½±å“åç»­åˆ†æ")
			// ä¸è¿”å›é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œåç»­æ“ä½œ
		}
	}

	return nil
}

// ============================================
// å•æ­¥äº¤äº’å¾ªç¯ï¼ˆæ–°æ–¹æ¡ˆï¼‰
// ============================================

// SingleStepAction å•æ­¥æ“ä½œç»“æœ
type SingleStepAction struct {
	Type      string `json:"type"`                // click, input, scroll, none
	X         int    `json:"x,omitempty"`         // ç‚¹å‡»åæ ‡X
	Y         int    `json:"y,omitempty"`         // ç‚¹å‡»åæ ‡Y
	Value     string `json:"value,omitempty"`     // inputç±»å‹çš„è¾“å…¥å€¼
	Direction string `json:"direction,omitempty"` // scrollæ–¹å‘: up/down/left/right
	Reason    string `json:"reason"`              // æ“ä½œåŸå› 
}

// PlanNextAction å•æ­¥äº¤äº’ï¼šåˆ†æå½“å‰UIï¼Œè¿”å›1ä¸ªæœ€ä¼˜æ“ä½œ
func (e *InteractionEngine) PlanNextAction(ctx context.Context, uiData *UIData, activityName string, step int, maxSteps int, history []*SingleStepAction) (*SingleStepAction, error) {
	// ã€ä¼˜å…ˆå¤„ç†ã€‘æ£€æµ‹ç™»å½•é¡µé¢çš„åè®®å¤é€‰æ¡†ï¼ˆå¿…é¡»å…ˆå‹¾é€‰æ‰èƒ½ç‚¹å‡»è¯•ç”¨ï¼‰
	checkboxAction := e.detectAgreementCheckbox(uiData, history)
	if checkboxAction != nil {
		e.logger.WithFields(logrus.Fields{
			"x":      checkboxAction.X,
			"y":      checkboxAction.Y,
			"reason": checkboxAction.Reason,
		}).Info("æ£€æµ‹åˆ°åè®®å¤é€‰æ¡†ï¼Œä¼˜å…ˆç‚¹å‡»")
		return checkboxAction, nil
	}

	// æ„å»ºç²¾ç®€æç¤ºè¯ï¼ˆåŒ…å«å†å²æ“ä½œï¼‰
	prompt := e.buildSingleStepPrompt(uiData, activityName, step, maxSteps, history)

	// æ‰“å°å‘é€ç»™AIçš„UIå…ƒç´ ï¼ˆæ–¹ä¾¿è°ƒè¯•ï¼‰
	uiElements := e.formatUIElementsCompact(uiData)
	e.logger.WithFields(logrus.Fields{
		"activity":    activityName,
		"step":        step,
		"max_steps":   maxSteps,
		"ui_elements": len(uiData.ClickableElements),
	}).Info("AIå•æ­¥åˆ†æè¯·æ±‚")

	// æ‰“å°å‰500å­—ç¬¦çš„UIå…ƒç´ ä¿¡æ¯
	uiPreview := uiElements
	if len(uiPreview) > 500 {
		uiPreview = uiPreview[:500] + "..."
	}
	e.logger.WithField("ui_preview", uiPreview).Info("å‘é€ç»™AIçš„UIå…ƒç´ ")

	// è°ƒç”¨AI
	aiResponse, err := e.callAI(ctx, prompt)
	if err != nil {
		e.logger.WithError(err).Warn("AIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥")
		return e.singleStepFallback(uiData), nil
	}

	// æ‰“å°AIåŸå§‹å“åº”
	responsePreview := aiResponse
	if len(responsePreview) > 300 {
		responsePreview = responsePreview[:300] + "..."
	}
	e.logger.WithField("ai_response", responsePreview).Info("AIåŸå§‹å“åº”")

	// è§£æå“åº”
	action, err := e.parseSingleStepResponse(aiResponse)
	if err != nil {
		e.logger.WithError(err).Warn("AIå“åº”è§£æå¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥")
		return e.singleStepFallback(uiData), nil
	}

	e.logger.WithFields(logrus.Fields{
		"type":   action.Type,
		"reason": action.Reason,
		"x":      action.X,
		"y":      action.Y,
	}).Info("AIè¿”å›å•æ­¥æ“ä½œ")

	return action, nil
}

// buildSingleStepPrompt æ„å»ºå•æ­¥äº¤äº’æç¤ºè¯
func (e *InteractionEngine) buildSingleStepPrompt(uiData *UIData, activityName string, step int, maxSteps int, history []*SingleStepAction) string {
	// ç®€åŒ–UIå…ƒç´ ä¿¡æ¯
	uiElements := e.formatUIElementsCompact(uiData)

	// æ„å»ºå†å²æ“ä½œä¿¡æ¯
	historyStr := ""
	if len(history) > 0 {
		var historyLines []string
		for i, action := range history {
			if i >= 5 { // æœ€å¤šæ˜¾ç¤ºæœ€è¿‘5æ¬¡æ“ä½œ
				break
			}
			historyLines = append(historyLines, fmt.Sprintf("- ç¬¬%dæ­¥: %s (%s)", i+1, action.Reason, action.Type))
		}
		historyStr = fmt.Sprintf("\n**å·²æ‰§è¡Œæ“ä½œ**:\n%s\nâš ï¸ ä¸è¦é‡å¤æ‰§è¡Œå·²åšè¿‡çš„æ“ä½œï¼å¦‚æœå¤é€‰æ¡†å·²ç‚¹å‡»è¿‡ï¼Œæ¥ä¸‹æ¥åº”è¯¥ç‚¹å‡»[è¯•ç”¨/è·³è¿‡]æŒ‰é’®ã€‚\n", strings.Join(historyLines, "\n"))
	}

	prompt := fmt.Sprintf(`ä½ æ˜¯Androidè‡ªåŠ¨åŒ–æµ‹è¯•ä¸“å®¶ã€‚åˆ†æå½“å‰ç•Œé¢ï¼Œè¿”å›ã€1ä¸ªæœ€ä¼˜æ“ä½œã€‘ä»¥è§¦å‘ç½‘ç»œè¯·æ±‚ã€‚

**ç•Œé¢ä¿¡æ¯**:
- Activity: %s
- ç¬¬ %d/%d æ­¥
%s
**UIå…ƒç´ ï¼ˆåæ ‡å·²ç»™å‡ºï¼Œå¿…é¡»ä½¿ç”¨è¿™äº›åæ ‡ï¼ï¼‰**:
%s

**ç­–ç•¥è§„åˆ™ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰**:
1. å¦‚æœå¤é€‰æ¡†å·²ç‚¹å‡»è¿‡ï¼ˆçœ‹å†å²æ“ä½œï¼‰ â†’ ç›´æ¥ç‚¹å‡»"è¯•ç”¨/è·³è¿‡"æŒ‰é’®
2. åè®®å¤é€‰æ¡† â†’ å¦‚æœé¡µé¢æœ‰"åŒæ„åè®®/éšç§æ”¿ç­–"æ–‡å­—ï¼Œæ‰¾åˆ°é™„è¿‘æ²¡æœ‰æ–‡å­—ä½†æœ‰IDçš„å°å…ƒç´ ï¼Œè¿™æ˜¯å¤é€‰æ¡†
3. è·³è¿‡ç™»å½•/è¯•ç”¨ â†’ ç‚¹å‡»ï¼ˆè¯•ç”¨/è·³è¿‡/æ¸¸å®¢/ä½“éªŒ/å…ˆé€›é€›/æš‚ä¸ç™»å½•/ç¨€åï¼‰
4. ç³»ç»ŸOpenæŒ‰é’® â†’ ç‚¹å‡»è¿›å…¥åº”ç”¨ï¼ˆOpen/æ‰“å¼€/å¯åŠ¨ï¼‰
5. æƒé™/åè®®åŒæ„ â†’ å¿…é¡»ç‚¹å‡»ï¼ˆåŒæ„/å…è®¸/ç¡®å®š/Accept/Allow/OK/ç»§ç»­/æˆ‘çŸ¥é“äº†ï¼‰
6. é«˜ä»·å€¼æŒ‰é’® â†’ è§¦å‘è¯·æ±‚ï¼ˆæœç´¢/åˆ·æ–°/åˆ†äº«/è¯¦æƒ…/æ›´å¤š/æŸ¥çœ‹/è¿›å…¥ï¼‰
7. å¯¼èˆªTab â†’ åˆ‡æ¢é¡µé¢ï¼ˆé¦–é¡µ/å‘ç°/æ¨è/æˆ‘çš„/æ¶ˆæ¯ï¼‰
8. æ»šåŠ¨æµè§ˆ â†’ è§¦å‘æ‡’åŠ è½½
9. ğŸš« ç¦æ­¢ç‚¹å‡»ï¼šæ‹’ç»/ä¸åŒæ„/å–æ¶ˆ/é€€å‡º/è¿”å›/å…³é—­/å¾®ä¿¡ç™»å½•/QQç™»å½•/æ‰‹æœºç™»å½•/ç™»å½•/æ³¨å†Œ

**âš ï¸ é‡è¦è§„åˆ™**:
- xå’Œyåæ ‡å¿…é¡»ä»ä¸Šé¢çš„UIå…ƒç´ åˆ—è¡¨ä¸­é€‰æ‹©ï¼Œä¸è¦è‡ªå·±ç¼–é€ åæ ‡ï¼
- ä¸è¦é‡å¤æ‰§è¡Œç›¸åŒåæ ‡çš„æ“ä½œï¼
- å¤é€‰æ¡†è¯†åˆ«ï¼šå¦‚æœåˆ—è¡¨ä¸­æœ‰ä¸€ä¸ªå…ƒç´ åªæœ‰IDæ²¡æœ‰æ–‡å­—ï¼ˆå¦‚"ID:xxx åæ ‡:(212,1991)"ï¼‰ï¼Œä¸”é™„è¿‘æœ‰"åè®®/æ”¿ç­–/åŒæ„"æ–‡å­—ï¼Œè¿™å°±æ˜¯å¤é€‰æ¡†

**è¾“å‡º**ï¼ˆä¸¥æ ¼JSONï¼Œåªè¿”å›ä¸€ä¸ªï¼‰:
{"type":"click","x":945,"y":125,"reason":"ç‚¹å‡»è¯•ç”¨æŒ‰é’®è·³è¿‡ç™»å½•"}
{"type":"scroll","direction":"down","reason":"å‘ä¸‹æ»šåŠ¨åŠ è½½æ›´å¤š"}
{"type":"none","reason":"çº¯å±•ç¤ºé¡µé¢ï¼Œæ— å¯æ“ä½œå…ƒç´ "}

åªè¿”å›JSONï¼Œä¸è¦ä»»ä½•è§£é‡Šã€‚`, activityName, step, maxSteps, historyStr, uiElements)

	return prompt
}

// detectAgreementCheckbox æ£€æµ‹ç™»å½•é¡µé¢çš„åè®®å¤é€‰æ¡†
// å¦‚æœæ£€æµ‹åˆ°æœªå‹¾é€‰çš„å¤é€‰æ¡†ï¼Œè¿”å›ç‚¹å‡»æ“ä½œï¼›å¦åˆ™è¿”å›nil
func (e *InteractionEngine) detectAgreementCheckbox(uiData *UIData, history []*SingleStepAction) *SingleStepAction {
	// æ£€æŸ¥å†å²æ“ä½œä¸­æ˜¯å¦å·²ç»ç‚¹å‡»è¿‡å¤é€‰æ¡†
	for _, action := range history {
		if strings.Contains(action.Reason, "å¤é€‰æ¡†") || strings.Contains(action.Reason, "checkbox") {
			return nil // å·²ç»ç‚¹å‡»è¿‡å¤é€‰æ¡†
		}
	}

	// æŸ¥æ‰¾åŒ…å«åè®®æ–‡å­—çš„å…ƒç´ 
	var agreementElem *UIElement
	for i := range uiData.ClickableElements {
		elem := &uiData.ClickableElements[i]
		text := strings.ToLower(elem.Text + elem.Label)
		if strings.Contains(text, "åŒæ„") && (strings.Contains(text, "åè®®") || strings.Contains(text, "æ”¿ç­–")) {
			agreementElem = elem
			break
		}
	}

	if agreementElem == nil {
		return nil // æ²¡æœ‰æ‰¾åˆ°åè®®æ–‡å­—
	}

	// æŸ¥æ‰¾åè®®æ–‡å­—é™„è¿‘çš„å°å…ƒç´ ï¼ˆå¯èƒ½æ˜¯å¤é€‰æ¡†ï¼‰
	// å¤é€‰æ¡†é€šå¸¸åœ¨åè®®æ–‡å­—çš„å·¦ä¾§ï¼ŒYåæ ‡ç›¸è¿‘
	agreementY := agreementElem.Center[1]
	var checkboxElem *UIElement

	for i := range uiData.ClickableElements {
		elem := &uiData.ClickableElements[i]
		// è·³è¿‡æœ‰æ–‡å­—çš„å…ƒç´ ï¼ˆå¤é€‰æ¡†é€šå¸¸æ²¡æœ‰æ–‡å­—ï¼‰
		if elem.Text != "" || elem.Label != "" {
			continue
		}

		// æ£€æŸ¥æ˜¯å¦åœ¨åè®®æ–‡å­—å·¦ä¾§
		if elem.Center[0] >= agreementElem.Center[0] {
			continue
		}

		// æ£€æŸ¥Yåæ ‡æ˜¯å¦æ¥è¿‘ï¼ˆÂ±100åƒç´ ï¼‰
		yDiff := elem.Center[1] - agreementY
		if yDiff < 0 {
			yDiff = -yDiff
		}
		if yDiff > 100 {
			continue
		}

		// æ£€æŸ¥å…ƒç´ å¤§å°ï¼ˆå¤é€‰æ¡†é€šå¸¸æ˜¯å°å…ƒç´ ï¼‰
		width := elem.Bounds[2] - elem.Bounds[0]
		height := elem.Bounds[3] - elem.Bounds[1]
		if width > 200 || height > 200 {
			continue
		}

		checkboxElem = elem
		break
	}

	if checkboxElem != nil {
		return &SingleStepAction{
			Type:   "click",
			X:      checkboxElem.Center[0],
			Y:      checkboxElem.Center[1],
			Reason: "ç‚¹å‡»åè®®å¤é€‰æ¡†ï¼ˆå¿…é¡»å…ˆå‹¾é€‰æ‰èƒ½ç»§ç»­ï¼‰",
		}
	}

	return nil
}

// formatUIElementsCompact æ ¼å¼åŒ–UIå…ƒç´ ï¼ˆç´§å‡‘ç‰ˆï¼‰
func (e *InteractionEngine) formatUIElementsCompact(uiData *UIData) string {
	var lines []string

	// å¯ç‚¹å‡»å…ƒç´ ï¼ˆæœ€å¤š20ä¸ªï¼‰
	for i, elem := range uiData.ClickableElements {
		if i >= 20 {
			lines = append(lines, fmt.Sprintf("... è¿˜æœ‰ %d ä¸ªå…ƒç´ ", len(uiData.ClickableElements)-20))
			break
		}

		text := elem.Label
		if text == "" {
			text = elem.Text
		}

		// æå–resource-idçš„æœ€åéƒ¨åˆ†
		resID := ""
		if elem.ResourceID != "" {
			parts := strings.Split(elem.ResourceID, "/")
			resID = parts[len(parts)-1]
		}

		line := fmt.Sprintf("%d. ", i+1)
		if text != "" {
			line += fmt.Sprintf("æ–‡æœ¬:\"%s\" ", text)
		}
		if resID != "" {
			line += fmt.Sprintf("ID:%s ", resID)
		}
		line += fmt.Sprintf("åæ ‡:(%d,%d)", elem.Center[0], elem.Center[1])

		lines = append(lines, line)
	}

	// è¾“å…¥æ¡†
	if len(uiData.InputFields) > 0 {
		lines = append(lines, "\nè¾“å…¥æ¡†:")
		for i, input := range uiData.InputFields {
			if i >= 5 {
				break
			}
			hint := input.Text
			if hint == "" {
				hint = "(æ— æç¤º)"
			}
			lines = append(lines, fmt.Sprintf("  - %s åæ ‡:(%d,%d)", hint, input.Center[0], input.Center[1]))
		}
	}

	// å¯æ»šåŠ¨åŒºåŸŸ
	if len(uiData.ScrollableViews) > 0 {
		lines = append(lines, "\né¡µé¢å¯æ»šåŠ¨")
	}

	if len(lines) == 0 {
		return "(æ— å¯äº¤äº’å…ƒç´ )"
	}

	return strings.Join(lines, "\n")
}

// parseSingleStepResponse è§£æå•æ­¥å“åº”
func (e *InteractionEngine) parseSingleStepResponse(response string) (*SingleStepAction, error) {
	// æ¸…ç†å“åº”ï¼Œæå–JSON
	response = strings.TrimSpace(response)

	// å°è¯•æå–JSONï¼ˆå¯èƒ½è¢«```åŒ…è£¹ï¼‰
	if strings.Contains(response, "```") {
		re := regexp.MustCompile("(?s)```(?:json)?\\s*(\\{.*?\\})\\s*```")
		matches := re.FindStringSubmatch(response)
		if len(matches) > 1 {
			response = matches[1]
		}
	}

	// æ‰¾åˆ°ç¬¬ä¸€ä¸ª { å’Œæœ€åä¸€ä¸ª }
	start := strings.Index(response, "{")
	end := strings.LastIndex(response, "}")
	if start >= 0 && end > start {
		response = response[start : end+1]
	}

	var action SingleStepAction
	if err := json.Unmarshal([]byte(response), &action); err != nil {
		return nil, fmt.Errorf("JSONè§£æå¤±è´¥: %w, åŸå§‹å“åº”: %s", err, response[:min(len(response), 200)])
	}

	// éªŒè¯type
	validTypes := map[string]bool{"click": true, "scroll": true, "input": true, "none": true}
	if !validTypes[action.Type] {
		return nil, fmt.Errorf("æ— æ•ˆçš„æ“ä½œç±»å‹: %s", action.Type)
	}

	// éªŒè¯åæ ‡ï¼ˆclickç±»å‹ï¼‰
	if action.Type == "click" {
		if action.X <= 0 || action.Y <= 0 || action.X > 1440 || action.Y > 3200 {
			return nil, fmt.Errorf("æ— æ•ˆçš„åæ ‡: (%d, %d)", action.X, action.Y)
		}
	}

	return &action, nil
}

// ============================================
// AIäº¤äº’å¾ªç¯ä¸»å‡½æ•°
// ============================================

// AILoopResult AIäº¤äº’å¾ªç¯ç»“æœ
type AILoopResult struct {
	TotalSteps      int                   // æ€»æ‰§è¡Œæ­¥æ•°
	SuccessSteps    int                   // æˆåŠŸæ‰§è¡Œæ­¥æ•°
	ExitReason      string                // é€€å‡ºåŸå› 
	Actions         []*SingleStepAction   // æ‰§è¡Œçš„æ“ä½œåˆ—è¡¨
	Errors          []string              // é”™è¯¯åˆ—è¡¨
}

// UIDataProvider UIæ•°æ®æä¾›æ¥å£
type UIDataProvider interface {
	DumpUIHierarchy(ctx context.Context) (string, error)
	TakeScreenshot(ctx context.Context, path string) error
}

// RunAIInteractionLoop æ‰§è¡ŒAIå•æ­¥äº¤äº’å¾ªç¯
// å‚æ•°:
//   - ctx: ä¸Šä¸‹æ–‡
//   - executor: åŠ¨ä½œæ‰§è¡Œå™¨ (ADBå®¢æˆ·ç«¯)
//   - uiProvider: UIæ•°æ®æä¾›å™¨
//   - packageName: ç›®æ ‡åº”ç”¨åŒ…å
//   - activityName: å½“å‰Activityåç§°
//   - maxSteps: æœ€å¤§æ‰§è¡Œæ­¥æ•°
//
// è¿”å›:
//   - AILoopResult: å¾ªç¯æ‰§è¡Œç»“æœ
func (e *InteractionEngine) RunAIInteractionLoop(
	ctx context.Context,
	executor ActionExecutor,
	uiProvider UIDataProvider,
	packageName string,
	activityName string,
	maxSteps int,
) *AILoopResult {
	result := &AILoopResult{
		Actions: make([]*SingleStepAction, 0),
		Errors:  make([]string, 0),
	}

	// ç”¨äºæ£€æµ‹é‡å¤æ“ä½œ
	var lastAction *SingleStepAction
	sameActionCount := 0
	noneCount := 0 // è¿ç»­noneè®¡æ•°

	e.logger.WithFields(logrus.Fields{
		"package":    packageName,
		"activity":   activityName,
		"max_steps":  maxSteps,
	}).Info("å¼€å§‹AIå•æ­¥äº¤äº’å¾ªç¯")

	for step := 1; step <= maxSteps; step++ {
		select {
		case <-ctx.Done():
			result.ExitReason = "ä¸Šä¸‹æ–‡å–æ¶ˆ"
			e.logger.Info("AIäº¤äº’å¾ªç¯: ä¸Šä¸‹æ–‡å–æ¶ˆ")
			return result
		default:
		}

		e.logger.WithField("step", step).Info("AIäº¤äº’å¾ªç¯: å¼€å§‹æ–°ä¸€æ­¥")

		// 1. æ£€æŸ¥å½“å‰æ˜¯å¦åœ¨ç›®æ ‡åº”ç”¨ä¸­
		currentPkg, err := executor.GetForegroundPackage(ctx)
		if err != nil {
			e.logger.WithError(err).Warn("è·å–å‰å°åº”ç”¨å¤±è´¥")
			result.Errors = append(result.Errors, fmt.Sprintf("æ­¥éª¤%d: è·å–å‰å°åº”ç”¨å¤±è´¥: %v", step, err))
			// å°è¯•æ¢å¤
			if recoveryErr := e.recoverToApp(ctx, executor, packageName); recoveryErr != nil {
				result.ExitReason = "åº”ç”¨æ¢å¤å¤±è´¥"
				e.logger.WithError(recoveryErr).Error("AIäº¤äº’å¾ªç¯: åº”ç”¨æ¢å¤å¤±è´¥ï¼Œé€€å‡º")
				return result
			}
			continue
		}

		if currentPkg != packageName {
			e.logger.WithFields(logrus.Fields{
				"current": currentPkg,
				"target":  packageName,
			}).Warn("ä¸åœ¨ç›®æ ‡åº”ç”¨ä¸­ï¼Œå°è¯•æ¢å¤")

			if recoveryErr := e.recoverToApp(ctx, executor, packageName); recoveryErr != nil {
				result.ExitReason = "åº”ç”¨æ¢å¤å¤±è´¥"
				e.logger.WithError(recoveryErr).Error("AIäº¤äº’å¾ªç¯: åº”ç”¨æ¢å¤å¤±è´¥ï¼Œé€€å‡º")
				return result
			}
			continue
		}

		// 2. è·å–UIæ•°æ®
		uiXML, err := uiProvider.DumpUIHierarchy(ctx)
		if err != nil {
			e.logger.WithError(err).Warn("è·å–UIå±‚çº§å¤±è´¥")
			result.Errors = append(result.Errors, fmt.Sprintf("æ­¥éª¤%d: è·å–UIå±‚çº§å¤±è´¥: %v", step, err))
			continue
		}

		// 3. è§£æUIæ•°æ®
		uiData, err := ParseUIXMLContent(uiXML)
		if err != nil {
			e.logger.WithError(err).Warn("è§£æUIå±‚çº§å¤±è´¥")
			result.Errors = append(result.Errors, fmt.Sprintf("æ­¥éª¤%d: è§£æUIå±‚çº§å¤±è´¥: %v", step, err))
			continue
		}

		// 4. è°ƒç”¨AIè·å–ä¸‹ä¸€æ­¥æ“ä½œï¼ˆä¼ é€’å†å²æ“ä½œï¼Œé¿å…é‡å¤ï¼‰
		action, err := e.PlanNextAction(ctx, uiData, activityName, step, maxSteps, result.Actions)
		if err != nil {
			e.logger.WithError(err).Warn("AIè§„åˆ’å¤±è´¥")
			result.Errors = append(result.Errors, fmt.Sprintf("æ­¥éª¤%d: AIè§„åˆ’å¤±è´¥: %v", step, err))
			continue
		}

		// 5. æ£€æŸ¥æ˜¯å¦ä¸ºnoneï¼ˆæ— æ“ä½œï¼‰
		if action.Type == "none" {
			noneCount++
			e.logger.WithFields(logrus.Fields{
				"reason":     action.Reason,
				"none_count": noneCount,
			}).Info("AIè¿”å›noneæ“ä½œ")

			// è¿ç»­3æ¬¡noneï¼Œé€€å‡ºå¾ªç¯
			if noneCount >= 3 {
				result.ExitReason = "è¿ç»­3æ¬¡æ— å¯æ“ä½œå…ƒç´ "
				e.logger.Info("AIäº¤äº’å¾ªç¯: è¿ç»­3æ¬¡noneï¼Œé€€å‡º")
				return result
			}

			// ç­‰å¾…ä¸€ä¸‹å†ç»§ç»­
			time.Sleep(1 * time.Second)
			continue
		}

		// é‡ç½®noneè®¡æ•°
		noneCount = 0

		// 6. æ£€æŸ¥æ˜¯å¦é‡å¤æ“ä½œ
		if lastAction != nil && isSameAction(lastAction, action) {
			sameActionCount++
			e.logger.WithFields(logrus.Fields{
				"action":     action.Type,
				"same_count": sameActionCount,
			}).Warn("æ£€æµ‹åˆ°é‡å¤æ“ä½œ")

			if sameActionCount >= 3 {
				result.ExitReason = "è¿ç»­3æ¬¡ç›¸åŒæ“ä½œ"
				e.logger.Info("AIäº¤äº’å¾ªç¯: é‡å¤æ“ä½œè¿‡å¤šï¼Œé€€å‡º")
				return result
			}
		} else {
			sameActionCount = 0
		}
		lastAction = action

		// 7. æ‰§è¡Œæ“ä½œ
		execErr := e.executeSingleStepAction(ctx, action, executor, packageName, activityName, uiXML)
		if execErr != nil {
			e.logger.WithError(execErr).Warn("æ‰§è¡Œæ“ä½œå¤±è´¥")
			result.Errors = append(result.Errors, fmt.Sprintf("æ­¥éª¤%d: æ‰§è¡Œæ“ä½œå¤±è´¥: %v", step, execErr))
			// ä¸é€€å‡ºï¼Œç»§ç»­ä¸‹ä¸€æ­¥
		} else {
			result.SuccessSteps++
		}

		result.TotalSteps = step
		result.Actions = append(result.Actions, action)

		// 8. ç­‰å¾…é¡µé¢ç¨³å®š
		time.Sleep(1500 * time.Millisecond)
	}

	result.ExitReason = "è¾¾åˆ°æœ€å¤§æ­¥æ•°"
	e.logger.WithField("max_steps", maxSteps).Info("AIäº¤äº’å¾ªç¯: è¾¾åˆ°æœ€å¤§æ­¥æ•°ï¼Œé€€å‡º")
	return result
}

// recoverToApp å°è¯•æ¢å¤åˆ°ç›®æ ‡åº”ç”¨
func (e *InteractionEngine) recoverToApp(ctx context.Context, executor ActionExecutor, packageName string) error {
	// å°è¯•3æ¬¡æ¢å¤
	for attempt := 1; attempt <= 3; attempt++ {
		e.logger.WithField("attempt", attempt).Info("å°è¯•æ¢å¤åˆ°ç›®æ ‡åº”ç”¨")

		var err error
		switch attempt {
		case 1:
			// æŒ‰è¿”å›é”®
			err = executor.PressBack(ctx)
		case 2:
			// å†æŒ‰è¿”å›é”®
			err = executor.PressBack(ctx)
		case 3:
			// é€šè¿‡monkeyå¯åŠ¨
			_, err = executor.Shell(ctx, fmt.Sprintf("monkey -p %s -c android.intent.category.LAUNCHER 1", packageName))
		}

		if err != nil {
			e.logger.WithError(err).Warn("æ¢å¤æ“ä½œå¤±è´¥")
			continue
		}

		time.Sleep(1 * time.Second)

		// æ£€æŸ¥æ˜¯å¦æ¢å¤æˆåŠŸ
		currentPkg, err := executor.GetForegroundPackage(ctx)
		if err == nil && currentPkg == packageName {
			e.logger.Info("åº”ç”¨æ¢å¤æˆåŠŸ")
			return nil
		}
	}

	return fmt.Errorf("æ¢å¤åˆ°åº”ç”¨ %s å¤±è´¥", packageName)
}

// executeSingleStepAction æ‰§è¡Œå•æ­¥æ“ä½œ
func (e *InteractionEngine) executeSingleStepAction(
	ctx context.Context,
	action *SingleStepAction,
	executor ActionExecutor,
	packageName string,
	activityName string,
	uiXML string,
) error {
	e.logger.WithFields(logrus.Fields{
		"type":   action.Type,
		"reason": action.Reason,
		"x":      action.X,
		"y":      action.Y,
	}).Info("æ‰§è¡Œå•æ­¥æ“ä½œ")

	switch action.Type {
	case "click":
		// å®‰å…¨æ£€æŸ¥
		preCheck := e.PreCheckAction(Action{
			Type: "click",
			X:    action.X,
			Y:    action.Y,
		}, uiXML, packageName, 1080, 2340)

		if !preCheck.Safe {
			e.logger.WithField("reason", preCheck.Reason).Warn("ç‚¹å‡»æ“ä½œè¢«å®‰å…¨æ£€æŸ¥æ‹¦æˆª")
			return fmt.Errorf("æ“ä½œè¢«æ‹¦æˆª: %s", preCheck.Reason)
		}

		// æ‰§è¡Œç‚¹å‡»
		if err := executor.TapScreen(ctx, action.X, action.Y); err != nil {
			return err
		}

		// ç­‰å¾…é¡µé¢å“åº”
		time.Sleep(500 * time.Millisecond)

		// æ£€æŸ¥æ˜¯å¦é€€å‡ºåº”ç”¨
		currentPkg, err := executor.GetForegroundPackage(ctx)
		if err == nil && currentPkg != packageName {
			e.logger.WithField("current_pkg", currentPkg).Warn("ç‚¹å‡»åé€€å‡ºäº†åº”ç”¨ï¼Œå°è¯•æ¢å¤")
			return e.recoverToApp(ctx, executor, packageName)
		}

	case "scroll":
		direction := action.Direction
		if direction == "" {
			direction = "down"
		}

		var cmd string
		switch direction {
		case "down":
			cmd = "input swipe 540 1500 540 500 300"
		case "up":
			cmd = "input swipe 540 500 540 1500 300"
		case "left":
			cmd = "input swipe 800 1000 200 1000 300"
		case "right":
			cmd = "input swipe 200 1000 800 1000 300"
		default:
			cmd = "input swipe 540 1500 540 500 300"
		}

		_, err := executor.Shell(ctx, cmd)
		if err != nil {
			return err
		}

	case "input":
		// å…ˆç‚¹å‡»è¾“å…¥æ¡†
		if err := executor.TapScreen(ctx, action.X, action.Y); err != nil {
			return err
		}
		time.Sleep(500 * time.Millisecond)

		// è¾“å…¥æ–‡æœ¬
		if action.Value != "" {
			if err := executor.InputText(ctx, action.Value); err != nil {
				return err
			}
		}

	case "none":
		// æ— æ“ä½œ
		return nil

	default:
		return fmt.Errorf("æœªçŸ¥æ“ä½œç±»å‹: %s", action.Type)
	}

	return nil
}

// isSameAction åˆ¤æ–­ä¸¤ä¸ªæ“ä½œæ˜¯å¦ç›¸åŒ
func isSameAction(a, b *SingleStepAction) bool {
	if a == nil || b == nil {
		return false
	}

	if a.Type != b.Type {
		return false
	}

	switch a.Type {
	case "click":
		// åæ ‡ç›¸å·®å°äº50è®¤ä¸ºæ˜¯åŒä¸€ä¸ªä½ç½®
		return abs(a.X-b.X) < 50 && abs(a.Y-b.Y) < 50
	case "scroll":
		return a.Direction == b.Direction
	case "input":
		return a.Value == b.Value
	default:
		return true
	}
}

// singleStepFallback å•æ­¥é™çº§ç­–ç•¥
func (e *InteractionEngine) singleStepFallback(uiData *UIData) *SingleStepAction {
	// ä¼˜å…ˆçº§å…³é”®è¯
	priorityKeywords := []struct {
		keywords []string
		priority int
	}{
		{[]string{"open", "æ‰“å¼€", "å¯åŠ¨", "launch"}, 16},
		{[]string{"åŒæ„", "agree", "å…è®¸", "allow", "ç¡®å®š", "ok", "accept", "ç»§ç»­", "continue", "æˆ‘çŸ¥é“äº†", "çŸ¥é“äº†"}, 15},
		{[]string{"è·³è¿‡", "skip", "æ¸¸å®¢", "guest", "è¯•ç”¨", "ä½“éªŒ", "å…ˆé€›é€›", "æš‚ä¸", "ç¨€å", "later"}, 14},
		{[]string{"æœç´¢", "search", "åˆ·æ–°", "refresh", "åˆ†äº«", "share", "è¯¦æƒ…", "detail", "æ›´å¤š", "more", "æŸ¥çœ‹", "view"}, 12},
		{[]string{"é¦–é¡µ", "home", "å‘ç°", "discover", "æ¨è", "æˆ‘çš„", "mine", "æ¶ˆæ¯", "message"}, 10},
	}

	// ç¦æ­¢å…³é”®è¯
	forbiddenKeywords := []string{
		"æ‹’ç»", "deny", "ä¸åŒæ„", "disagree", "å–æ¶ˆ", "cancel",
		"é€€å‡º", "exit", "è¿”å›", "back", "å…³é—­", "close",
		"ç™»å½•", "login", "æ³¨å†Œ", "register", "signin", "signup",
	}

	var bestAction *SingleStepAction
	bestPriority := -1

	for _, elem := range uiData.ClickableElements {
		combined := strings.ToLower(elem.Text + " " + elem.Label + " " + elem.ResourceID)

		// æ£€æŸ¥æ˜¯å¦ç¦æ­¢
		isForbidden := false
		for _, kw := range forbiddenKeywords {
			if strings.Contains(combined, kw) {
				isForbidden = true
				break
			}
		}
		if isForbidden {
			continue
		}

		// æ£€æŸ¥ä¼˜å…ˆçº§
		for _, p := range priorityKeywords {
			for _, kw := range p.keywords {
				if strings.Contains(combined, kw) {
					if p.priority > bestPriority {
						bestPriority = p.priority
						text := elem.Label
						if text == "" {
							text = elem.Text
						}
						bestAction = &SingleStepAction{
							Type:   "click",
							X:      elem.Center[0],
							Y:      elem.Center[1],
							Reason: fmt.Sprintf("é™çº§ç­–ç•¥: ç‚¹å‡» %s", text),
						}
					}
					break
				}
			}
		}
	}

	// å¦‚æœæ²¡æœ‰æ‰¾åˆ°é«˜ä¼˜å…ˆçº§æŒ‰é’®ï¼Œå°è¯•æ»šåŠ¨
	if bestAction == nil && len(uiData.ScrollableViews) > 0 {
		return &SingleStepAction{
			Type:      "scroll",
			Direction: "down",
			Reason:    "é™çº§ç­–ç•¥: å‘ä¸‹æ»šåŠ¨",
		}
	}

	// å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œè¿”å›none
	if bestAction == nil {
		return &SingleStepAction{
			Type:   "none",
			Reason: "é™çº§ç­–ç•¥: æ— å¯æ“ä½œå…ƒç´ ",
		}
	}

	return bestAction
}
