#!/usr/bin/env python3
"""
GIT-GuardNet 恶意检测推理服务

Flask API 服务器，整合 Drebin、MH-100K、CICMalDroid 三个模型
与 Go 应用在同一容器内运行，共享 APK 目录

启动方式:
    python scripts/malware_server.py
    或
    gunicorn -w 2 -b 0.0.0.0:5000 scripts.malware_server:app
"""

import os
import sys
import time
import logging
from datetime import datetime
from flask import Flask, request, jsonify
from flask_cors import CORS

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# 确定项目根目录和模型目录
# 支持两种运行方式：从项目根目录运行 或 从 scripts 目录运行
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if os.path.basename(SCRIPT_DIR) == 'scripts':
    PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
else:
    PROJECT_ROOT = SCRIPT_DIR

MODELS_DIR = os.path.join(PROJECT_ROOT, 'models')

# CICMalDroid 判定阈值
CICMALDROID_MALWARE_THRESHOLD = 0.6

# 添加模型目录到路径
sys.path.insert(0, MODELS_DIR)
sys.path.insert(0, PROJECT_ROOT)

logger.info(f"Project root: {PROJECT_ROOT}")
logger.info(f"Models dir: {MODELS_DIR}")

# 延迟导入模型相关库
import torch
import numpy as np

# 导入各模型检测器
DREBIN_AVAILABLE = False
MH100K_AVAILABLE = False
CICMALDROID_AVAILABLE = False

try:
    from drebin.detect import (
        load_model as load_drebin_model,
        extract_features_from_apk as extract_drebin_features,
        predict_single as predict_drebin
    )
    DREBIN_AVAILABLE = True
    logger.info("Drebin module imported successfully")
except ImportError as e:
    logger.warning(f"Drebin module not available: {e}")

try:
    from mh100k.detect import (
        load_model as load_mh100k_model,
        extract_features_from_apk as extract_mh100k_features,
        predict as predict_mh100k
    )
    MH100K_AVAILABLE = True
    logger.info("MH-100K module imported successfully")
except ImportError as e:
    logger.warning(f"MH-100K module not available: {e}")

try:
    from cicmaldroid.detect import (
        load_model as load_cicmaldroid_model,
        extract_features_from_apk as extract_cicmaldroid_features,
        predict as predict_cicmaldroid,
        load_scaler as load_cicmaldroid_scaler
    )
    CICMALDROID_AVAILABLE = True
    logger.info("CICMalDroid module imported successfully")
except ImportError as e:
    logger.warning(f"CICMalDroid module not available: {e}")

# Flask 应用
app = Flask(__name__)
CORS(app)

# 全局模型实例
models = {}
device = None


def initialize_models():
    """初始化所有可用模型"""
    global models, device

    # 选择设备
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    logger.info(f"Using device: {device}")

    # 加载 Drebin 模型
    if DREBIN_AVAILABLE:
        try:
            drebin_path = os.path.join(MODELS_DIR, 'drebin', 'checkpoints', 'best_model.pth')
            if os.path.exists(drebin_path):
                model, use_temporal = load_drebin_model(drebin_path, device)
                models['drebin'] = {
                    'model': model,
                    'use_temporal': use_temporal,
                    'extract': extract_drebin_features,
                    'predict': predict_drebin
                }
                logger.info("✓ Drebin model loaded")
            else:
                logger.warning(f"Drebin checkpoint not found: {drebin_path}")
        except Exception as e:
            logger.error(f"Failed to load Drebin model: {e}")

    # 加载 MH-100K 模型
    if MH100K_AVAILABLE:
        try:
            mh100k_path = os.path.join(MODELS_DIR, 'mh100k', 'checkpoints', 'best_model.pth')
            if os.path.exists(mh100k_path):
                model, config = load_mh100k_model(mh100k_path, device)
                models['mh100k'] = {
                    'model': model,
                    'config': config,
                    'extract': extract_mh100k_features,
                    'predict': predict_mh100k
                }
                logger.info("✓ MH-100K model loaded")
            else:
                logger.warning(f"MH-100K checkpoint not found: {mh100k_path}")
        except Exception as e:
            logger.error(f"Failed to load MH-100K model: {e}")

    # 加载 CICMalDroid 模型
    if CICMALDROID_AVAILABLE:
        try:
            # 优先使用 checkpoints_full（如果存在），否则使用 checkpoints
            cic_path = os.path.join(MODELS_DIR, 'cicmaldroid', 'checkpoints_full', 'best_model.pth')
            scaler_path = os.path.join(MODELS_DIR, 'cicmaldroid', 'checkpoints_full', 'scaler.pkl')

            if not os.path.exists(cic_path):
                cic_path = os.path.join(MODELS_DIR, 'cicmaldroid', 'checkpoints', 'best_model.pth')
                scaler_path = os.path.join(MODELS_DIR, 'cicmaldroid', 'checkpoints', 'scaler.pkl')

            if os.path.exists(cic_path):
                model, config = load_cicmaldroid_model(cic_path, device)
                scaler = load_cicmaldroid_scaler(scaler_path) if os.path.exists(scaler_path) else None
                models['cicmaldroid'] = {
                    'model': model,
                    'config': config,
                    'scaler': scaler,
                    'extract': extract_cicmaldroid_features,
                    'predict': predict_cicmaldroid
                }
                logger.info("✓ CICMalDroid model loaded")
            else:
                logger.warning(f"CICMalDroid checkpoint not found: {cic_path}")
        except Exception as e:
            logger.error(f"Failed to load CICMalDroid model: {e}")

    logger.info(f"Models loaded: {list(models.keys())}")
    return len(models) > 0


def summarize_drebin_features(features):
    """生成与 Go API 一致的特征摘要结构"""
    if not features or not isinstance(features, dict):
        return {}

    static = features.get('static_features')
    nodes = features.get('node_features')
    adj = features.get('adj_matrix')

    if static is None:
        return {}

    static = np.asarray(static)
    nodes = np.asarray(nodes) if nodes is not None else None
    adj = np.asarray(adj) if adj is not None else None

    summary = {
        'static_features': {
            'dangerous_permissions': int(np.sum(static[:50] > 0)),
            'suspicious_intents': int(np.sum(static[50:125] > 0)),
            'sensitive_apis': int(np.sum(static[125:215] > 0)),
            'total_features': int(np.sum(static > 0))
        }
    }

    if nodes is not None and adj is not None:
        num_nodes = int(np.sum(np.any(nodes != 0, axis=1)))
        num_edges = int(np.sum(adj > 0))
        avg_degree = float(np.mean(np.sum(adj > 0, axis=1))) if adj.size else 0.0
        summary['graph_features'] = {
            'num_nodes': num_nodes,
            'num_edges': num_edges,
            'avg_degree': avg_degree
        }

    return summary


@app.route('/api/v1/health', methods=['GET'])
def health_check():
    """健康检查接口"""
    return jsonify({
        'status': 'healthy' if models else 'degraded',
        'models_loaded': len(models) > 0,
        'available_models': list(models.keys()),
        'device': str(device),
        'project_root': PROJECT_ROOT,
        'models_dir': MODELS_DIR,
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/v1/models', methods=['GET'])
def list_models():
    """列出可用模型"""
    model_info = []

    for name in models.keys():
        model_info.append({
            'name': name,
            'description': get_model_description(name),
            'loaded': True
        })

    return jsonify({
        'models': list(models.keys()),
        'model_info': model_info,
        'device': str(device)
    })


def get_model_description(name):
    """获取模型描述"""
    descriptions = {
        'drebin': 'Drebin 二分类模型 (Malware/Benign)',
        'mh100k': 'MH-100K 大规模特征模型',
        'cicmaldroid': 'CICMalDroid 15分类家族识别模型'
    }
    return descriptions.get(name, 'Unknown model')


@app.route('/api/v1/detect', methods=['POST'])
def detect():
    """
    执行恶意检测

    Request Body:
    {
        "apk_path": "/app/inbound_apks/xxx.apk",
        "task_id": "xxx",
        "models": ["drebin", "mh100k", "cicmaldroid"],
        "options": {
            "extract_graph_features": true,
            "extract_temporal_features": false,
            "use_ensemble": false
        }
    }
    """
    try:
        data = request.get_json()

        if not data:
            return jsonify({
                'success': False,
                'error': 'No JSON data provided',
                'error_type': 'validation'
            }), 400

        apk_path = data.get('apk_path', '')
        task_id = data.get('task_id', '')
        requested_models = data.get('models', ['drebin'])
        options = data.get('options', {})

        # 验证 APK 路径
        if not apk_path:
            return jsonify({
                'success': False,
                'error': 'apk_path is required',
                'error_type': 'validation'
            }), 400

        # 处理相对路径：如果是相对路径，转换为基于项目根目录的绝对路径
        if not os.path.isabs(apk_path):
            apk_path = os.path.join(PROJECT_ROOT, apk_path)

        if not os.path.exists(apk_path):
            return jsonify({
                'success': False,
                'error': f'APK file not found: {apk_path}',
                'error_type': 'file_not_found'
            }), 400

        logger.info(f"Detection request: task_id={task_id}, apk={os.path.basename(apk_path)}, models={requested_models}")

        start_time = time.time()

        # 执行各模型检测
        model_results = {}
        errors = []
        extraction_time = 0
        inference_time = 0
        feature_summary = None

        for model_name in requested_models:
            if model_name not in models:
                errors.append(f"Model '{model_name}' not available")
                continue

            try:
                result = run_model_detection(model_name, apk_path, options)
                if model_name == 'drebin':
                    feature_summary = result.pop('feature_summary', None)
                model_results[model_name] = result
                extraction_time += result.get('extraction_time_ms', 0)
                inference_time += result.get('inference_time_ms', 0)
            except Exception as e:
                logger.error(f"Model {model_name} detection failed: {e}", exc_info=True)
                errors.append(f"{model_name}: {str(e)}")

        total_time = (time.time() - start_time) * 1000

        # 综合决策
        detection_result = aggregate_results(model_results, options.get('use_ensemble', False))
        if feature_summary:
            detection_result['feature_summary'] = feature_summary
        detection_result['extraction_time_ms'] = extraction_time
        detection_result['inference_time_ms'] = inference_time
        detection_result['total_time_ms'] = int(total_time)
        detection_result['errors'] = errors

        # 添加各模型详细结果
        if 'drebin' in model_results:
            detection_result['drebin_result'] = model_results['drebin']
        if 'mh100k' in model_results:
            detection_result['mh100k_result'] = model_results['mh100k']
        if 'cicmaldroid' in model_results:
            detection_result['cicmaldroid_result'] = model_results['cicmaldroid']

        return jsonify({
            'success': True,
            'task_id': task_id,
            'detection_results': detection_result
        })

    except Exception as e:
        logger.exception(f"Detection error: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_type': 'internal'
        }), 500


def run_model_detection(model_name, apk_path, options):
    """运行单个模型检测"""
    model_info = models[model_name]
    model = model_info['model']

    start_extract = time.time()

    if model_name == 'drebin':
        features = model_info['extract'](apk_path)
        feature_summary = summarize_drebin_features(features)
        extraction_time = (time.time() - start_extract) * 1000

        start_infer = time.time()
        result = model_info['predict'](model, features, device, model_info['use_temporal'])
        inference_time = (time.time() - start_infer) * 1000

        return {
            'is_malware': result['is_malware'],
            'confidence': result['confidence'],
            'malware_probability': result['malware_probability'],
            'benign_probability': result['benign_probability'],
            'feature_summary': feature_summary,
            'extraction_time_ms': int(extraction_time),
            'inference_time_ms': int(inference_time)
        }

    elif model_name == 'mh100k':
        features = model_info['extract'](apk_path)
        extraction_time = (time.time() - start_extract) * 1000

        start_infer = time.time()
        result = model_info['predict'](model, features, device)
        inference_time = (time.time() - start_infer) * 1000

        return {
            'is_malware': result['is_malware'],
            'confidence': result['confidence'],
            'malware_probability': result.get('malware_probability', result['confidence'] if result['is_malware'] else 1 - result['confidence']),
            'benign_probability': result.get('benign_probability', 1 - result['confidence'] if result['is_malware'] else result['confidence']),
            'extraction_time_ms': int(extraction_time),
            'inference_time_ms': int(inference_time)
        }

    elif model_name == 'cicmaldroid':
        config = model_info['config']
        features, info = model_info['extract'](apk_path, config['input_dim'])
        extraction_time = (time.time() - start_extract) * 1000

        start_infer = time.time()
        result = model_info['predict'](model, features, device, model_info.get('scaler'))
        inference_time = (time.time() - start_infer) * 1000

        return {
            'is_malware': result['is_malware'],
            'confidence': result['confidence'],
            'category': result['category'],
            'danger_level': result['danger_level'],
            'top5_predictions': result['top5_predictions'],
            'malware_probability': 1 - result['all_probabilities'].get('Benign', 0),
            'benign_probability': result['all_probabilities'].get('Benign', 0),
            'extraction_time_ms': int(extraction_time),
            'inference_time_ms': int(inference_time)
        }

    return {}


def aggregate_results(model_results, use_ensemble=False):
    """
    聚合多模型结果

    决策逻辑：
    1. 优先使用高置信度的二分类模型（Drebin/MH-100K）判断是否为恶意
    2. 二分类模型置信度 > 90% 时，信任其判断
    3. 如果判定为恶意，使用 CICMalDroid 做家族分类
    4. CICMalDroid 单独判断时，需要置信度 > 60% 才判定为恶意
    """
    if not model_results:
        return {
            'is_malware': False,
            'confidence': 0.0,
            'malware_probability': 0.0,
            'benign_probability': 1.0,
            'predicted_family': 'Unknown',
            'feature_source': 'none'
        }

    # 收集二分类模型结果
    binary_results = {}
    if 'drebin' in model_results:
        binary_results['drebin'] = model_results['drebin']
    if 'mh100k' in model_results:
        binary_results['mh100k'] = model_results['mh100k']

    # CICMalDroid 结果
    cic_result = model_results.get('cicmaldroid')

    if use_ensemble:
        # 集成投票：使用加权平均概率
        malware_probs = []
        weights = []
        for name, result in model_results.items():
            prob = result.get('malware_probability', 0.5)
            conf = result.get('confidence', 0.5)
            malware_probs.append(prob)
            # 权重：二分类模型权重更高
            weight = 2.0 if name in ['drebin', 'mh100k'] else 1.0
            weights.append(weight * conf)

        total_weight = sum(weights)
        if total_weight > 0:
            avg_malware = sum(p * w for p, w in zip(malware_probs, weights)) / total_weight
        else:
            avg_malware = np.mean(malware_probs)
        avg_benign = 1 - avg_malware
        is_malware = avg_malware > 0.5
        confidence = avg_malware if is_malware else avg_benign
    else:
        # 智能决策：优先信任高置信度的二分类模型
        is_malware = False
        confidence = 0.0
        avg_malware = 0.0
        avg_benign = 1.0

        if binary_results:
            # 分析两个二分类模型的结果
            drebin = binary_results.get('drebin', {})
            mh100k = binary_results.get('mh100k', {})

            drebin_malware = drebin.get('is_malware', False)
            drebin_conf = drebin.get('confidence', 0.0)
            mh100k_malware = mh100k.get('is_malware', False)
            mh100k_conf = mh100k.get('confidence', 0.0)

            # 情况1: 两个模型结果一致
            if drebin_malware == mh100k_malware:
                # 取置信度最高的
                if drebin_conf >= mh100k_conf:
                    best_binary = drebin
                    best_conf = drebin_conf
                else:
                    best_binary = mh100k
                    best_conf = mh100k_conf
                is_malware = drebin_malware  # 两个一致，取任意一个
                confidence = best_conf
                avg_malware = best_binary.get('malware_probability', 0.5)
                avg_benign = best_binary.get('benign_probability', 0.5)
                logger.info(f"Binary classifiers agree: is_malware={is_malware}, confidence={confidence:.2%}")

            # 情况2: 两个模型结果冲突
            else:
                # 安全优先策略：如果任一模型以高置信度(>=80%)判定恶意，则判定为恶意
                malware_high_conf = (drebin_malware and drebin_conf >= 0.8) or (mh100k_malware and mh100k_conf >= 0.8)

                if malware_high_conf:
                    # 有高置信度恶意判定，采用恶意结果
                    is_malware = True
                    if drebin_malware:
                        best_binary = drebin
                        confidence = drebin_conf
                    else:
                        best_binary = mh100k
                        confidence = mh100k_conf
                    avg_malware = best_binary.get('malware_probability', 0.5)
                    avg_benign = best_binary.get('benign_probability', 0.5)
                    logger.info(f"Conflict resolved (safety-first): is_malware=True, confidence={confidence:.2%}")
                else:
                    # 都不是高置信度，使用加权投票
                    # malware_probability 加权平均
                    drebin_mp = drebin.get('malware_probability', 0.5)
                    mh100k_mp = mh100k.get('malware_probability', 0.5)
                    # 权重 = 置信度
                    total_weight = drebin_conf + mh100k_conf
                    if total_weight > 0:
                        weighted_malware = (drebin_mp * drebin_conf + mh100k_mp * mh100k_conf) / total_weight
                    else:
                        weighted_malware = (drebin_mp + mh100k_mp) / 2

                    is_malware = weighted_malware > 0.5
                    confidence = abs(weighted_malware - 0.5) * 2  # 归一化到 0-1
                    avg_malware = weighted_malware
                    avg_benign = 1 - weighted_malware
                    best_binary = drebin if drebin_conf >= mh100k_conf else mh100k
                    logger.info(f"Conflict resolved (weighted vote): is_malware={is_malware}, weighted_prob={weighted_malware:.2%}")

            if best_binary and (drebin_conf >= 0.7 or mh100k_conf >= 0.7):
                # 至少有一个模型置信度 >= 70%，使用二分类结果
                logger.info(f"Using binary classifier result: is_malware={is_malware}, confidence={confidence:.2%}")
            elif cic_result:
                # 二分类模型置信度不够高，参考 CICMalDroid
                cic_conf = cic_result.get('confidence', 0.0)
                cic_malware = cic_result.get('is_malware', False)

                # CICMalDroid 需要置信度 > 60% 才判定为恶意
                if cic_malware and cic_conf >= CICMALDROID_MALWARE_THRESHOLD:
                    is_malware = True
                    confidence = cic_conf
                    avg_malware = cic_result.get('malware_probability', 0.5)
                    avg_benign = cic_result.get('benign_probability', 0.5)
                else:
                    # CICMalDroid 置信度不够，使用二分类结果
                    if best_binary:
                        is_malware = best_binary.get('is_malware', False)
                        confidence = best_conf
                        avg_malware = best_binary.get('malware_probability', 0.5)
                        avg_benign = best_binary.get('benign_probability', 0.5)
                logger.info(f"CICMalDroid conf={cic_conf:.2%}, final: is_malware={is_malware}")
        elif cic_result:
            # 只有 CICMalDroid，需要更高置信度
            cic_conf = cic_result.get('confidence', 0.0)
            cic_malware = cic_result.get('is_malware', False)

            # 单独使用 CICMalDroid 时，需要置信度 > 60%
            if cic_malware and cic_conf >= CICMALDROID_MALWARE_THRESHOLD:
                is_malware = True
            else:
                is_malware = False

            confidence = cic_conf
            avg_malware = cic_result.get('malware_probability', 0.5)
            avg_benign = cic_result.get('benign_probability', 0.5)

    # 获取预测家族（仅 CICMalDroid 提供）
    predicted_family = 'Unknown'
    if cic_result:
        # 只有判定为恶意时才显示家族
        if is_malware:
            predicted_family = cic_result.get('category', 'Unknown')
        else:
            predicted_family = 'Benign'

    # 构建家族概率分布
    family_probabilities = []
    if 'cicmaldroid' in model_results and 'top5_predictions' in model_results['cicmaldroid']:
        for cat, prob in model_results['cicmaldroid']['top5_predictions']:
            family_probabilities.append({
                'family': cat,
                'probability': prob
            })

    return {
        'is_malware': is_malware,
        'confidence': confidence,
        'malware_probability': avg_malware,
        'benign_probability': avg_benign,
        'predicted_family': predicted_family,
        'family_probabilities': family_probabilities,
        'feature_source': 'apk',
        'models_used': list(model_results.keys())
    }


def main():
    """主入口"""
    port = int(os.environ.get('MALWARE_SERVER_PORT', 5000))
    debug = os.environ.get('DEBUG', 'false').lower() == 'true'

    # 初始化模型
    success = initialize_models()
    if not success:
        logger.warning("No models loaded, service will run in degraded mode")

    logger.info(f"Starting GIT-GuardNet Malware Detection Server on port {port}")
    app.run(host='0.0.0.0', port=port, debug=debug, threaded=True)


if __name__ == '__main__':
    main()
